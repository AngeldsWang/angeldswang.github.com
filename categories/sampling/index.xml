<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sampling on Brave Matrix</title>
    <link>https://angeldswang.github.io/categories/sampling/index.xml</link>
    <description>Recent content in Sampling on Brave Matrix</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://angeldswang.github.io/categories/sampling/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rejection Sampling</title>
      <link>https://angeldswang.github.io/post/2014-08-11-rejection-sampling/</link>
      <pubDate>Tue, 19 Aug 2014 03:11:55 +0800</pubDate>
      
      <guid>https://angeldswang.github.io/post/2014-08-11-rejection-sampling/</guid>
      <description>&lt;p&gt;如何产生符合一定分布的随机变量？对于简单的随机变量，我们往往可以直接获得其概率分布函数&lt;code&gt;$ F(x)=P(X\leqslant x) $&lt;/code&gt;。但是对于更多复杂的随机变量来说，获得其概率分布的解析表达式是不可能的。对于这种情况，要产生这样的随机变量就需要另辟蹊径。&lt;strong&gt;Rejection sampling&lt;/strong&gt;就是其中最具代表性的一种。下文主要参考了&lt;a href=&#34;http://www.columbia.edu/~ks20/4703-Sigman/Monte-Carlo-Sigman.html&#34; title=&#34;Karl Sigman&#39;s Lecture Notes on Monte Carlo Simulation&#34;&gt;Karl Sigman的notes&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Rejection sampling的主要思想是用另一个容易产生的概率分布&lt;code&gt;$ G $&lt;/code&gt;，(它的概率密度是&lt;code&gt;$ g(x) $&lt;/code&gt;)，来尽可能的逼近所求的概率分布&lt;code&gt;$ F $&lt;/code&gt;。形式化出来就是，这两个概率分布密度的比有明确的上界&lt;code&gt;$ c $&lt;/code&gt;，即&lt;code&gt;$ \text{sup}_x\{f(x)/g(x)\}\leqslant c $&lt;/code&gt;。实际中，&lt;code&gt;$ c $&lt;/code&gt;的值尽可能的接近&lt;code&gt;$ 1 $&lt;/code&gt;。下面首先来看如何用Rejection sampling来获得连续随机变量。对于离散随机变量，情况基本类似。
&lt;br&gt;
&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;用rejection-sampling算法产生连续随机变量&#34;&gt;用Rejection sampling算法产生连续随机变量&lt;/h3&gt;

&lt;table border=&#39;2&#39; cellpadding=&#39;15px&#39; bordercolor=&#39;#5050&#39;&gt;
&lt;td&gt;
&lt;ol&gt;
&lt;li&gt;生成服从概率分布$G$的随机变量$Y$。&lt;/li&gt; &lt;p/&gt;
&lt;li&gt;从均匀分布$Uniform(0,1)$采样获得一个随机变量$U$(和$Y$相互独立)。&lt;/li&gt; &lt;p/&gt;
&lt;li&gt;If $U\leqslant \frac{f(Y)}{cg(Y)}$，then $X=Y$(&#34;accept&#34;); Otherwise goto step 1 (&#34;reject&#34;)。&lt;/li&gt; 
&lt;/ol&gt;
&lt;/td&gt;
&lt;/table&gt;

&lt;p&gt;在证明上述算法之前，有以下几点值得我们注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$ f(Y) $&lt;/code&gt;和&lt;code&gt;$ g(Y) $&lt;/code&gt;都是随机变量，因此&lt;code&gt;$ \frac{f(Y)}{cg(Y)} $&lt;/code&gt;也是一个随机变量。这一比值和step 2 中的随机变量&lt;code&gt;$ U $&lt;/code&gt;是相互独立的。&lt;/li&gt;
&lt;li&gt;这一比值是以0和1为上下界的，即&lt;code&gt;$ 0\leqslant \frac{f(Y)}{cg(Y)}\leqslant 1 $&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;step 1 和 step 2 调用的次数&lt;code&gt;$ N $&lt;/code&gt;(也就是成功采样获得一个&lt;code&gt;$ X $&lt;/code&gt;所需的迭代次数)本身也是一个服从几何分布的随机变量。其一次试验就发生的概率&lt;code&gt;$ p=P(U\leqslant \frac{f(Y)}{cg(Y)}) $&lt;/code&gt;，则&lt;code&gt;$ P(N=n)=(1-p)^{n-1}p, n\geqslant 1 $&lt;/code&gt;。因此迭代次数的期望为&lt;code&gt;$ E(N)=1/p $&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;最终，我们可以将所期望获得的随机变量&lt;code&gt;$ X $&lt;/code&gt;的概率分布&lt;code&gt;$ F $&lt;/code&gt;等价于在事件&lt;code&gt;$ \{U\leqslant \frac{f(Y)}{cg(Y)}\} $&lt;/code&gt;发生的条件下，随机变量&lt;code&gt;$ Y $&lt;/code&gt;的概率分布。
&lt;br/&gt;
另外，若以随机变量&lt;code&gt;$ Y $&lt;/code&gt;为条件，事件&lt;code&gt;$ \{U\leqslant \frac{f(Y)}{cg(Y)}\} $&lt;/code&gt;发生的概率为：&lt;code&gt;$ P(U\leqslant \frac{f(Y)}{cg(Y)}|Y=y)=\frac{f(y)}{cg(y)} $&lt;/code&gt;。考虑到&lt;code&gt;$ Y $&lt;/code&gt;的概率密度为&lt;code&gt;$ g(y) $&lt;/code&gt;，通过去条件化并对&lt;code&gt;$ Y $&lt;/code&gt;所有可能的值上进行积分，这样就可以得到&lt;code&gt;$ p=P(U\leqslant \frac{f(Y)}{cg(Y)}) $&lt;/code&gt;，即：
&lt;code&gt;$$
\begin{align*} 
p &amp;amp; = \int_{-\infty}^{\infty}\frac{f(y)}{cg(y)}\times g(y)\text{d}y\\
&amp;amp; = \frac{1}{c}\int_{-\infty}^{\infty}f(y)\text{d}y\\
&amp;amp; = \frac{1}{c} 
\end{align*}
$$&lt;/code&gt;
因此，算法的迭代次数的期望即为&lt;code&gt;$ E(N)=c $&lt;/code&gt;。从这个角度上可以看出，若要使得算法的迭代次数尽可能少，等价于最小化上确界常数&lt;code&gt;$ c $&lt;/code&gt;。
算法成功采样一个随机变量&lt;code&gt;$ X $&lt;/code&gt;所需的迭代次数的期望即为上确界常数&lt;code&gt;$ c=\text{sup}_x\{f(x)/g(x)\} $&lt;/code&gt;。
&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;rejection-sampling算法证明&#34;&gt;Rejection sampling算法证明&lt;/h3&gt;

&lt;p&gt;由上述说明可知，要证明Rejection sampling算法可行，只需要证明&lt;code&gt;$ \text{在给定条件}U\leqslant b\frac{f(Y)}{cg(Y)}\text{下}，\text{随机变量}Y\text{的概率分布即为}F，\text{即}，P(Y\leqslant y|U\leqslant \frac{f(Y)}{cg(Y)})=F(y) $&lt;/code&gt;。
令&lt;code&gt;$ B=\{U\leqslant \frac{f(Y)}{cg(Y)}\} $&lt;/code&gt;，&lt;code&gt;$ A=\{Y\leqslant y\} $&lt;/code&gt;，又因为&lt;code&gt;$ P(B)=p=\frac{1}{c} $&lt;/code&gt;，根据贝叶斯公式：
&lt;code&gt;$$ 
\begin{align*}
\frac{P(B|A)P(A)}{P(B)} &amp;amp;= P(U\leqslant \frac{f(Y)}{cg(Y)}|Y=y)\times \frac{G(y)}{1/c}\\
                        &amp;amp;= \frac{P(U\leqslant \frac{f(Y)}{cg(Y)}, Y=y)}{G(y)}\times \frac{G(y)}{1/c}\\
                        &amp;amp;= c\int_{-\infty}^yP(U\leqslant \frac{f(Y)}{cg(Y)}|Y=w\leqslant y)g(w)\text{d}w\\
                        &amp;amp;= c\int_{-\infty}^y\frac{f(w)}{cg(w)}g(w)\text{d}w\\
                        &amp;amp;= \int_{-\infty}^yf(w)\text{d}w\\
                        &amp;amp;= F(y)=P(A|B)=P(Y\leqslant y|U\leqslant \frac{f(Y)}{cg(Y)})~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\blacksquare
\end{align*}
$$&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;用rejection-sampling算法产生离散随机变量&#34;&gt;用Rejection sampling算法产生离散随机变量&lt;/h3&gt;

&lt;p&gt;产生离散随机变量的方法和产生连续随机变量的方法基本一致，只是这时候目标的概率分布函数&lt;code&gt;$ F $&lt;/code&gt;变成了概率质量函数&lt;code&gt;$ p(k)=P(X=k) $&lt;/code&gt;，辅助的概率分布&lt;code&gt;$ G $&lt;/code&gt;变成了概率质量函数&lt;code&gt;$ q(k)=P(Y=k) $&lt;/code&gt;，并满足条件&lt;code&gt;$ \text{sup}_x\{p(k)/q(k)\}\leqslant c &amp;lt; \infty $&lt;/code&gt;。
&lt;br&gt;
&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;示例-产生服从简单beta分布的随机变量&#34;&gt;示例：产生服从简单Beta分布的随机变量&lt;/h3&gt;

&lt;p&gt;Beta分布的概率密度函数为&lt;code&gt;$ f(x)=bx^n(1-x)^m，x\in (0,1) $&lt;/code&gt;，其中&lt;code&gt;$ b=[\int_0^1x^n(1-x)^m\text{d}x]^{-1} $&lt;/code&gt;为归一化常数。这里我们只研究&lt;code&gt;$ n=m&amp;gt;1 $&lt;/code&gt;的情况，此时Beta分布的概率密度函数关于&lt;code&gt;$ x=\frac{1}{2} $&lt;/code&gt;对称。这里我们选择&lt;code&gt;$ g(y)=1 $&lt;/code&gt;这一均匀分布作为辅助的概率密度函数。因此，&lt;code&gt;$ c=\text{sup}_x\frac{f(x)}{g(x)}=\text{sup}_xf(x) $&lt;/code&gt;当&lt;code&gt;$ x=\frac{1}{2} $&lt;/code&gt;时取到最大，即&lt;code&gt;$ c=b4^{-n} $&lt;/code&gt;。
这样，若要产生服从&lt;code&gt;$ f(x)=b(x(1-x))^n $&lt;/code&gt;这一简单Beta分布的随机变量，只需要：&lt;/p&gt;

&lt;table border=&#39;2&#39; cellpadding=&#39;15px&#39; bordercolor=&#39;#5050&#39;&gt;
&lt;td&gt;
&lt;ol&gt;
&lt;li&gt;产生两个0，1之间的均匀分布随机变量$U_1，U_2$。&lt;/li&gt; &lt;p/&gt;
&lt;li&gt;If $U_2\leqslant 4^n(U_1(1-U_1))^n$，then $X=U_1$; Otherwise goto step 1。&lt;/li&gt; 
&lt;/ol&gt;
&lt;/td&gt;
&lt;/table&gt;</description>
    </item>
    
  </channel>
</rss>