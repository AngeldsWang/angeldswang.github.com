<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Brave Matrix</title>
    <link>https://angeldswang.github.io/post/index.xml</link>
    <description>Recent content in Posts on Brave Matrix</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 28 Jan 2015 15:35:55 +0800</lastBuildDate>
    <atom:link href="https://angeldswang.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Run script after Angularjs ng-repeat finishing</title>
      <link>https://angeldswang.github.io/post/2015-01-28-run-script-after-angularjs/</link>
      <pubDate>Wed, 28 Jan 2015 15:35:55 +0800</pubDate>
      
      <guid>https://angeldswang.github.io/post/2015-01-28-run-script-after-angularjs/</guid>
      <description>&lt;p&gt;这几天在做一个小项目的时候，用到了&lt;a href=&#34;http://vnjs.net/www/project/freewall/&#34;&gt;Freewall&lt;/a&gt;这个很nice的插件。它可以很方便的替你实现很多不错的grid layout。但在用到&lt;a href=&#34;http://vnjs.net/www/project/freewall/example/pinterest-layout.html&#34;&gt;Pinterest style layout&lt;/a&gt;的时候遇到了一个问题。官方给出的example如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;freewall&amp;quot; class=&amp;quot;free-wall&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;brick&amp;quot;&amp;gt;
        &amp;lt;img src=&amp;quot;i/photo/1.jpg&amp;quot; width=&amp;quot;100%&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;info&amp;quot;&amp;gt;
            &amp;lt;h3&amp;gt;Freewall&amp;lt;/h3&amp;gt;
            &amp;lt;h5&amp;gt;Pinterest layout&amp;lt;/h5&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;brick&amp;quot;&amp;gt;
        &amp;lt;img src=&amp;quot;i/photo/2.jpg&amp;quot; width=&amp;quot;100%&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;info&amp;quot;&amp;gt;
            &amp;lt;h3&amp;gt;Freewall&amp;lt;/h3&amp;gt;
            &amp;lt;h5&amp;gt;Pinterest layout&amp;lt;/h5&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    ....
&amp;lt;/div&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    var wall = new freewall(&amp;quot;#freewall&amp;quot;);
    wall.reset({
        selector: &#39;.brick&#39;,
        animate: true,
        cellW: 200,
        cellH: &#39;auto&#39;,
        onResize: function() {
            wall.fitWidth();
        }
    });

    wall.container.find(&#39;.brick img&#39;).load(function() {
        wall.fitWidth();
    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里省略了样式的代码，直接看这些最核心的部分。一看很简单，就一堆自己的图片加上用&lt;code&gt;freewall&lt;/code&gt;初始化一下整个图片墙就行了。可是我自己的代码怎么都没法在网页加载的初期就能&lt;code&gt;fitWidth&lt;/code&gt;。但是可以响应&lt;code&gt;onResize&lt;/code&gt;。我的代码如下。(就是把example的&lt;a href=&#34;http://html2jade.org/&#34;&gt;html转成jade&lt;/a&gt;，偷懒了^_^)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jade&#34;&gt;extends layout

block content
  #bgimg(ng-if=&#39;!currTrend&#39;)
    img(src=&#39;/images/bgImg.png&#39;, width=&#39;100%&#39;)
  #bgimg(ng-if=&#39;currTrend&#39;)
    #freewall.free-wall(ng-hide=&#39;!searched&#39;)
      .brick(ng-repeat=&#39;tweetinfo in trendinfo&#39;)
        img(ng-src=&#39;{{tweetinfo.imageURL}}&#39;, width=&#39;100%&#39;)
        .info
          ...

    script(type=&#39;text/javascript&#39;).
      var wall = new freewall(&amp;quot;#freewall&amp;quot;);
      wall.reset({
        selector: &#39;.brick&#39;,
        animate: true,
        cellW: 200,
        cellH: &#39;auto&#39;,
        onResize: function() {
          wall.fitWidth();
        }
      });
      wall.container.find(&#39;.brick img&#39;).load(function() {
        wall.fitWidth();
      });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;思来想去可能是我用了Angularjs的ng-repeat动态从服务器端读图片过来的问题，我试了下，一个个的手打这些图片列表是可以出来&lt;code&gt;fitWidth&lt;/code&gt;的效果的。综合以上分析，既然用ng-repeat的时候是可以响应&lt;code&gt;onResize&lt;/code&gt;的，说明脚本肯定是被执行了，但是整个图片墙没有去&lt;code&gt;fitWidth&lt;/code&gt;只能说明这些&lt;code&gt;brick&lt;/code&gt;是异步添加的。实际运行的时候，脚本早就先运行完了，才慢慢的从服务器端通过http读过来的图片。这样&lt;code&gt;wall.container.find(&#39;.brick img&#39;).load&lt;/code&gt;之前执行了也没什么效果。那么怎么才能同步这些脚本呢？查来查去，发现可以用Angularjs里面的&lt;code&gt;directive&lt;/code&gt;来实现这一过程。&lt;/p&gt;

&lt;p&gt;首先给循环中的每个&lt;code&gt;brick&lt;/code&gt;添加一个检测ng-repeat完成的事件发射器，并将其封装成一个叫&lt;code&gt;repeatBrick&lt;/code&gt;的directive。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;angular.module(&#39;YourModule&#39;,[])
  .controller(&#39;YourCtrl&#39;, function ($scope, $http) {
   // do other things
})
.directive(&#39;repeatBrick&#39;, function() {
  return function(scope, element, attrs) {
    if (scope.$last){	// detect the last brick
      scope.$emit(&#39;LastBrick&#39;);	// emit the `LastBrick` event
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在自定义一个&lt;code&gt;freewall&lt;/code&gt;上的directive。在里面监听&lt;code&gt;LastBrick&lt;/code&gt;事件，并在其回调函数中执行之前的脚本就行了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;.directive(&#39;theFreewall&#39;, function() {
  return function(scope, element, attrs) {
    scope.$on(&#39;LastBrick&#39;, function(event){	// listen to the `LastBrick` event
      var wall = new freewall(&amp;quot;#freewall&amp;quot;);	// run the script in callback function 
      wall.reset({
        selector: &#39;.brick&#39;,
        animate: true,
        cellW: 200,
        cellH: &#39;auto&#39;,
        onResize: function() {
          wall.fitWidth();
        }
      });
      wall.container.find(&#39;.brick img&#39;).load(function() {
        wall.fitWidth();
      });
    });
  };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然这时候在模板中还要加上这两个directives。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jade&#34;&gt;extends layout

block content
  #bgimg(ng-if=&#39;!currTrend&#39;)
    img(src=&#39;/images/bgImg.png&#39;, width=&#39;100%&#39;)
  #bgimg(ng-if=&#39;currTrend&#39;)
    #freewall.free-wall(ng-hide=&#39;!searched&#39; the-freewall)	//- add `theFreewall` directive
      .brick(ng-repeat=&#39;tweetinfo in trendinfo&#39; repeat-brick)	//- add `repeatBrick` directive
        img(ng-src=&#39;{{tweetinfo.imageURL}}&#39;, width=&#39;100%&#39;)
        .info
          ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就能确保在读取完这些图片之后立刻执行脚本进行布局。总结来说就是传统的html+js是顺序执行的，但是一旦引入模板引擎或者像Angularjs这样的指令之后，很可能就变成异步执行的了，这是个得注意的小坑。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Why Modulo $1e9&#43;7$</title>
      <link>https://angeldswang.github.io/post/2014-11-09-why-modulo-1e7-plus-7/</link>
      <pubDate>Sun, 09 Nov 2014 21:15:55 +0800</pubDate>
      
      <guid>https://angeldswang.github.io/post/2014-11-09-why-modulo-1e7-plus-7/</guid>
      <description>&lt;p&gt;一直很好奇很多编程问题，比如求大数阶乘，大数的排列组合等，要求将输出结果对&lt;code&gt;$ 1e9+7 $&lt;/code&gt;(=1000000007)取模。为什么是这样一个数呢？今天一查，网上还是有不少讨论的。总结一下有下面几个原因。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先因为&lt;code&gt;$ 1e9+7 $&lt;/code&gt;是一个质数&lt;/li&gt;
&lt;li&gt;其次是&lt;code&gt;$ 1e9+7 $&lt;/code&gt;对于int32来说足够大&lt;/li&gt;
&lt;li&gt;还有就是&lt;code&gt;$ 1e9+7 $&lt;/code&gt;的平方对于int64来说也恰好不会溢出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
其实对于后两点来说都是比较好理解的。足够大是因为取模的结果尽量不重复，跟哈希表一样(应该说哈希表跟它一样，明显它更本质一点#_#)。对于平方不会对int64溢出意味着对于很大数相乘依然可以利用&lt;code&gt;$ 1e9+7 $&lt;/code&gt;取模到int32基本数据类型中。而对于为什么要求质数，等介绍完模运算就能很好的理解了。&lt;/p&gt;

&lt;h2 id=&#34;模运算&#34;&gt;模运算&lt;/h2&gt;

&lt;p&gt;假设有&lt;code&gt;$ a\equiv c(\text{mod} ~m) $&lt;/code&gt;， &lt;code&gt;$ b\equiv d(\text{mod} ~m) $&lt;/code&gt;，则对于基本算术运算有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$ a+b\equiv    c+d(\text{mod} ~m) $&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$ a-b\equiv    c-d(\text{mod} ~m) $&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$ a\times b\equiv c\times d(\text{mod} ~m) $&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$ a/ b\not\equiv c/ d(\text{mod} ~m) $&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而且满足以下分配率：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$ ( a + b ) \% c = ( ( a \% c ) + ( b \% c ) ) \% c $&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$ ( a * b ) \% c = ( ( a \% c ) * ( b \% c ) ) \% c $&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$ ( a – b ) \% c = ( ( a \% c ) – ( b \% c ) ) \% c $&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$ ( a / b ) \% c \neq ( ( a \% c ) / ( b \% c ) ) \% c $&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意到取模除法是不满足分配率的。(万恶的根源。。。)&lt;/p&gt;

&lt;p&gt;对于上述分配率一个很常见的应用就是求大数的阶乘了，结果对&lt;code&gt;$ M=1e9+7 $&lt;/code&gt;取模。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef long long ll;
ll factorial(int n, int M) {
    ll ans = 1;
    while(n &amp;gt;= 1) {
        ans = (ans * n);
        n--;
    }
    return ans % M;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果直接计算对最后的结果再取模的话很可能在累乘的时候就已经溢出int64了，所以这种写法是错误的。正确的写法就是利用模乘法的分配率的性质在每一步乘法计算的时候都对结果取模。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef long long ll;
ll factorial(int n, int M) {
    ll ans = 1;
    while(n &amp;gt;= 1) {
        ans = (ans * n) % M;
        n--;
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面就来详细说说为什么一定要&lt;code&gt;$ M $&lt;/code&gt;是一个质数。首先还得从模除法不满足分配率开始说起。
既然除法不满足分配率，那把除法转化成乘法不就行了。那么模除法能不能像一般数值运算一样简单的把除以
&lt;code&gt;$ a $&lt;/code&gt;变成乘以&lt;code&gt;$ a^{-1} $&lt;/code&gt;呢。直观上想好像不行，但是有什么可以难倒代数学家呢，人家早就从群啊环啊什么的定义好这些了，直接搬过来就行了，那就是——&lt;code&gt;$ \ulcorner $&lt;/code&gt; &lt;strong&gt;逆元&lt;/strong&gt; &lt;code&gt;$ \lrcorner $&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;逆元&#34;&gt;逆元&lt;/h2&gt;

&lt;p&gt;逆元的定义很简单：满足&lt;code&gt;$ ax\equiv 1(\text{mod} ~M) $&lt;/code&gt;，则&lt;code&gt;$ x=a^{-1} $&lt;/code&gt;就是&lt;code&gt;$ a $&lt;/code&gt;的逆元。&lt;/p&gt;

&lt;p&gt;一旦有了逆元，&lt;code&gt;$ (a / b) \% c $&lt;/code&gt;就可以写成&lt;code&gt;$ (a * b^{-1}) \% c $&lt;/code&gt;。这样转换成乘法之后分配率也适用了。&lt;/p&gt;

&lt;p&gt;但是注意到如果&lt;code&gt;$ \text{gcd}(a,M)!=1 $&lt;/code&gt;的话，&lt;code&gt;$ a $&lt;/code&gt;的逆元是不存在的。所以如果&lt;code&gt;$ M $&lt;/code&gt;是一个质数的话&lt;code&gt;$ \text{gcd}(a,M)!=1 $&lt;/code&gt;一般都成立了吧。这还不够！因为如果&lt;code&gt;$ a $&lt;/code&gt;恰好是&lt;code&gt;$ M $&lt;/code&gt;的倍数的话依然不满足条件啊，所以如果&lt;code&gt;$ M $&lt;/code&gt;足够大的话，比如&lt;code&gt;$ 1e9+7 $&lt;/code&gt;(&lt;a href=&#34;http://www.bilibili.com/video/av362069/&#34;&gt;一般问题也不会让你求&lt;code&gt;$ 1e9+7 $&lt;/code&gt;的阶乘吧&lt;/a&gt;)，基本就能够满足&lt;code&gt;$ \text{gcd}(a,M)!=1 $&lt;/code&gt;这个条件了。&lt;/p&gt;

&lt;p&gt;那么如何计算一个数的逆元呢？&lt;/p&gt;

&lt;p&gt;最简单的就是暴力搜索了。对于&lt;code&gt;$ ax\equiv 1(\text{mod} ~M) $&lt;/code&gt;只需要对&lt;code&gt;$ x=[1, M-1] $&lt;/code&gt;(因为对&lt;code&gt;$ M $&lt;/code&gt;取模的结果是以&lt;code&gt;$ 0,1,2,\ldots,M-1 $&lt;/code&gt;为周期的)计算一遍找出和&lt;code&gt;$ a $&lt;/code&gt;相乘&lt;code&gt;$ \text{mod} ~M $&lt;/code&gt;等于1的数就是&lt;code&gt;$ a $&lt;/code&gt;的逆元了。但是这种算法的复杂度是&lt;code&gt;$ \mathcal{O}(M) $&lt;/code&gt;。而一般情况下&lt;code&gt;$ M  $&lt;/code&gt;的取值非常大，如本文讨论的&lt;code&gt;$ 1e9+7 $&lt;/code&gt;这么大的话，这种线性复杂度就是不可以接受的了。更高效的算法有两种，一种是
&lt;strong&gt;Extended Eucledian algorithm&lt;/strong&gt; (扩展欧几里德算法)，另外一种是利用&lt;strong&gt;Fermat&amp;rsquo;s Little Theorem&lt;/strong&gt; (费马小定理)。&lt;/p&gt;

&lt;h2 id=&#34;extended-eucledian-algorithm&#34;&gt;Extended Eucledian algorithm&lt;/h2&gt;

&lt;p&gt;我们都知道欧几里德算法，又叫辗转相除法是用来求两个数的最大公约数的。那么扩展欧几里德算法又是干什么的呢。扩展欧几里德算法是用来求解不定方程：&lt;code&gt;$ ax+by=\text{gcd}(a,b) $&lt;/code&gt;(这个方程又叫&lt;a href=&#34;http://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity&#34;&gt;贝祖等式&lt;/a&gt;)。&lt;/p&gt;

&lt;p&gt;求满足&lt;code&gt;$ ax\equiv 1(\text{mod} ~M) $&lt;/code&gt;，&lt;code&gt;$ a $&lt;/code&gt;的逆元只需要将方程变形成&lt;code&gt;$ ax-My=1 $&lt;/code&gt;，因为要满足&lt;code&gt;$ \text{gcd}(a,M)=1 $&lt;/code&gt;，所以等式右边为&lt;code&gt;$ 1 $&lt;/code&gt;。这样就可以利用扩展欧几里德算法来解出&lt;code&gt;$ x $&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;table border=&#39;2&#39; cellpadding=&#39;15px&#39; bordercolor=&#39;#505050&#39;&gt;
&lt;td&gt;
&lt;ol&gt;
&lt;li&gt;当$b=0$时，$\text{gcd}(a,b)=a$。此时$x=1$，$y=0$。(递归终止条件)&lt;/li&gt; &lt;p/&gt;
&lt;li&gt;当$ab!=0$时，设原始方程为：$ax_1+by_1=\text{gcd}(a,b)$，并存在：
   $bx_2+(a\%b)y_2=\text{gcd}(b,a\%b)$。由辗转相除法可知$\text{gcd}(a,b)=\text{gcd}(b,a\%b)$&lt;br/&gt;
   所以有：$ax_1+by_1=bx_2+(a\%b)y_2$。&lt;br/&gt;
   即：$ax_1+by_1=bx_2+(a-(a/b)\times b)y_2=ay_2+b(x_2-(a/b)\times y_2)$&lt;br/&gt;
   所以：$x_1=y_2$$，$$y1=x2-(a/b)\times y_2$&lt;br/&gt;
   也就是说只要求出$x_2$和$y_2$就能根据上述等式求得$x_1$和$y_2$。这样就可以利用递归定义，直到满足递归终止条件为止，再一步步返回计算出$x$和$y$。&lt;/li&gt; &lt;p/&gt;
&lt;/ol&gt;
&lt;/td&gt;
&lt;/table&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int extgcd(int a, int b, int &amp;amp;x, int &amp;amp;y) {
    int d = a;
    if (b != 0) {
    	d = extgcd(b, a % b, y, x);
        y -= (a / b) * x;
    } else {
    	x = 1;
        y = 0;
    }
    return d;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;扩展欧几里德算法的复杂度和辗转相除法是一样的(只是多了一步计算)，都是
&lt;code&gt;$ \mathcal{O}(\text{log}~\text{max}(a,b)) $&lt;/code&gt;。利用扩展欧几里德算法就可以很方便地求得
&lt;code&gt;$ a $&lt;/code&gt;的逆元(&lt;code&gt;$ \text{mod} ~M $&lt;/code&gt;)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int mod_inverse(int a, int M) {
    int x, y;
    extgcd(a, M, x, y);
    return (M + x % M) % M;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里用不到extgcd的返回值了(因为肯定是&lt;code&gt;$ 1 $&lt;/code&gt;)。返回值的时候加上&lt;code&gt;$ M $&lt;/code&gt;是为了防止当&lt;code&gt;$ x $&lt;/code&gt;为负数的时候，有些编译器会将&lt;code&gt;$ x\%M $&lt;/code&gt;返回负数，加上&lt;code&gt;$ M $&lt;/code&gt;让其值回到&lt;code&gt;$ [0,M-1] $&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;fermat-s-little-theorem&#34;&gt;Fermat&amp;rsquo;s Little Theorem&lt;/h2&gt;

&lt;p&gt;费马小定理说的是：对于任意正整数&lt;code&gt;$ a $&lt;/code&gt;和质数&lt;code&gt;$ p $&lt;/code&gt;，满足&lt;code&gt;$ a^p\equiv a(\text{mod} ~p) $&lt;/code&gt;。而且如果&lt;code&gt;$ a $&lt;/code&gt;不是&lt;code&gt;$ p  $&lt;/code&gt;的倍数时，条件等价成&lt;code&gt;$ a^{p-1}\equiv 1(\text{mod} ~p) $&lt;/code&gt;。利用这条性质可以很方便的求解逆元。&lt;code&gt;$ ax\equiv 1(\text{mod} ~M) $&lt;/code&gt;，这里质数&lt;code&gt;$ p=M $&lt;/code&gt;，则&lt;code&gt;$ a^{p-1}\equiv 1(\text{mod} ~p) $&lt;/code&gt;=&lt;code&gt;$ a\cdot a^{M-2}\equiv 1(\text{mod} ~M) $&lt;/code&gt;。也就是说&lt;code&gt;$ a(\text{mod} ~M) $&lt;/code&gt;的逆元&lt;code&gt;$ x=a^{M-2}(\text{mod} ~M) $&lt;/code&gt;。这样就可以通过快速幂运算来求解逆元。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef long long ll;
ll fast_pow(ll a, ll n, ll M) {
    ll res = 1;
    while (n &amp;gt; 0) {
    	if (n &amp;amp; 1) res = res * a % M;
        a = a * a % M;
        n &amp;gt;&amp;gt;= 1;
    }
    return res;
}

ll mod_inverse(ll a, ll M) {
    return fast_pow(a,M-2,M);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说了这么多，总结一下就是在一些组合问题中由于数值太大需要对结果取模。在计算的时候，特别是在计算排列组合的时候会不可避免的遇到模除法，为了使得除法计算起来符合数值运算的过程就需要引入逆元的概念，在计算逆元的时候&lt;code&gt;$ M $&lt;/code&gt;一定要是一个质数，这个质数一定得足够大，要不然取模后的结果很多都相同了造成无法判断问题输出的正确性。所以很多问题就用了&lt;code&gt;$ 1e9+7 $&lt;/code&gt;这个数了。。。。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rejection Sampling</title>
      <link>https://angeldswang.github.io/post/2014-08-11-rejection-sampling/</link>
      <pubDate>Tue, 19 Aug 2014 03:11:55 +0800</pubDate>
      
      <guid>https://angeldswang.github.io/post/2014-08-11-rejection-sampling/</guid>
      <description>&lt;p&gt;如何产生符合一定分布的随机变量？对于简单的随机变量，我们往往可以直接获得其概率分布函数&lt;code&gt;$ F(x)=P(X\leqslant x) $&lt;/code&gt;。但是对于更多复杂的随机变量来说，获得其概率分布的解析表达式是不可能的。对于这种情况，要产生这样的随机变量就需要另辟蹊径。&lt;strong&gt;Rejection sampling&lt;/strong&gt;就是其中最具代表性的一种。下文主要参考了&lt;a href=&#34;http://www.columbia.edu/~ks20/4703-Sigman/Monte-Carlo-Sigman.html&#34; title=&#34;Karl Sigman&#39;s Lecture Notes on Monte Carlo Simulation&#34;&gt;Karl Sigman的notes&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Rejection sampling的主要思想是用另一个容易产生的概率分布&lt;code&gt;$ G $&lt;/code&gt;，(它的概率密度是&lt;code&gt;$ g(x) $&lt;/code&gt;)，来尽可能的逼近所求的概率分布&lt;code&gt;$ F $&lt;/code&gt;。形式化出来就是，这两个概率分布密度的比有明确的上界&lt;code&gt;$ c $&lt;/code&gt;，即&lt;code&gt;$ \text{sup}_x\{f(x)/g(x)\}\leqslant c $&lt;/code&gt;。实际中，&lt;code&gt;$ c $&lt;/code&gt;的值尽可能的接近&lt;code&gt;$ 1 $&lt;/code&gt;。下面首先来看如何用Rejection sampling来获得连续随机变量。对于离散随机变量，情况基本类似。
&lt;br&gt;
&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;用rejection-sampling算法产生连续随机变量&#34;&gt;用Rejection sampling算法产生连续随机变量&lt;/h3&gt;

&lt;table border=&#39;2&#39; cellpadding=&#39;15px&#39; bordercolor=&#39;#5050&#39;&gt;
&lt;td&gt;
&lt;ol&gt;
&lt;li&gt;生成服从概率分布$G$的随机变量$Y$。&lt;/li&gt; &lt;p/&gt;
&lt;li&gt;从均匀分布$Uniform(0,1)$采样获得一个随机变量$U$(和$Y$相互独立)。&lt;/li&gt; &lt;p/&gt;
&lt;li&gt;If $U\leqslant \frac{f(Y)}{cg(Y)}$，then $X=Y$(&#34;accept&#34;); Otherwise goto step 1 (&#34;reject&#34;)。&lt;/li&gt; 
&lt;/ol&gt;
&lt;/td&gt;
&lt;/table&gt;

&lt;p&gt;在证明上述算法之前，有以下几点值得我们注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$ f(Y) $&lt;/code&gt;和&lt;code&gt;$ g(Y) $&lt;/code&gt;都是随机变量，因此&lt;code&gt;$ \frac{f(Y)}{cg(Y)} $&lt;/code&gt;也是一个随机变量。这一比值和step 2 中的随机变量&lt;code&gt;$ U $&lt;/code&gt;是相互独立的。&lt;/li&gt;
&lt;li&gt;这一比值是以0和1为上下界的，即&lt;code&gt;$ 0\leqslant \frac{f(Y)}{cg(Y)}\leqslant 1 $&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;step 1 和 step 2 调用的次数&lt;code&gt;$ N $&lt;/code&gt;(也就是成功采样获得一个&lt;code&gt;$ X $&lt;/code&gt;所需的迭代次数)本身也是一个服从几何分布的随机变量。其一次试验就发生的概率&lt;code&gt;$ p=P(U\leqslant \frac{f(Y)}{cg(Y)}) $&lt;/code&gt;，则&lt;code&gt;$ P(N=n)=(1-p)^{n-1}p, n\geqslant 1 $&lt;/code&gt;。因此迭代次数的期望为&lt;code&gt;$ E(N)=1/p $&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;最终，我们可以将所期望获得的随机变量&lt;code&gt;$ X $&lt;/code&gt;的概率分布&lt;code&gt;$ F $&lt;/code&gt;等价于在事件&lt;code&gt;$ \{U\leqslant \frac{f(Y)}{cg(Y)}\} $&lt;/code&gt;发生的条件下，随机变量&lt;code&gt;$ Y $&lt;/code&gt;的概率分布。
&lt;br/&gt;
另外，若以随机变量&lt;code&gt;$ Y $&lt;/code&gt;为条件，事件&lt;code&gt;$ \{U\leqslant \frac{f(Y)}{cg(Y)}\} $&lt;/code&gt;发生的概率为：&lt;code&gt;$ P(U\leqslant \frac{f(Y)}{cg(Y)}|Y=y)=\frac{f(y)}{cg(y)} $&lt;/code&gt;。考虑到&lt;code&gt;$ Y $&lt;/code&gt;的概率密度为&lt;code&gt;$ g(y) $&lt;/code&gt;，通过去条件化并对&lt;code&gt;$ Y $&lt;/code&gt;所有可能的值上进行积分，这样就可以得到&lt;code&gt;$ p=P(U\leqslant \frac{f(Y)}{cg(Y)}) $&lt;/code&gt;，即：
&lt;code&gt;$$
\begin{align*} 
p &amp;amp; = \int_{-\infty}^{\infty}\frac{f(y)}{cg(y)}\times g(y)\text{d}y\\
&amp;amp; = \frac{1}{c}\int_{-\infty}^{\infty}f(y)\text{d}y\\
&amp;amp; = \frac{1}{c} 
\end{align*}
$$&lt;/code&gt;
因此，算法的迭代次数的期望即为&lt;code&gt;$ E(N)=c $&lt;/code&gt;。从这个角度上可以看出，若要使得算法的迭代次数尽可能少，等价于最小化上确界常数&lt;code&gt;$ c $&lt;/code&gt;。
算法成功采样一个随机变量&lt;code&gt;$ X $&lt;/code&gt;所需的迭代次数的期望即为上确界常数&lt;code&gt;$ c=\text{sup}_x\{f(x)/g(x)\} $&lt;/code&gt;。
&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;rejection-sampling算法证明&#34;&gt;Rejection sampling算法证明&lt;/h3&gt;

&lt;p&gt;由上述说明可知，要证明Rejection sampling算法可行，只需要证明&lt;code&gt;$ \text{在给定条件}U\leqslant b\frac{f(Y)}{cg(Y)}\text{下}，\text{随机变量}Y\text{的概率分布即为}F，\text{即}，P(Y\leqslant y|U\leqslant \frac{f(Y)}{cg(Y)})=F(y) $&lt;/code&gt;。
令&lt;code&gt;$ B=\{U\leqslant \frac{f(Y)}{cg(Y)}\} $&lt;/code&gt;，&lt;code&gt;$ A=\{Y\leqslant y\} $&lt;/code&gt;，又因为&lt;code&gt;$ P(B)=p=\frac{1}{c} $&lt;/code&gt;，根据贝叶斯公式：
&lt;code&gt;$$ 
\begin{align*}
\frac{P(B|A)P(A)}{P(B)} &amp;amp;= P(U\leqslant \frac{f(Y)}{cg(Y)}|Y=y)\times \frac{G(y)}{1/c}\\
                        &amp;amp;= \frac{P(U\leqslant \frac{f(Y)}{cg(Y)}, Y=y)}{G(y)}\times \frac{G(y)}{1/c}\\
                        &amp;amp;= c\int_{-\infty}^yP(U\leqslant \frac{f(Y)}{cg(Y)}|Y=w\leqslant y)g(w)\text{d}w\\
                        &amp;amp;= c\int_{-\infty}^y\frac{f(w)}{cg(w)}g(w)\text{d}w\\
                        &amp;amp;= \int_{-\infty}^yf(w)\text{d}w\\
                        &amp;amp;= F(y)=P(A|B)=P(Y\leqslant y|U\leqslant \frac{f(Y)}{cg(Y)})~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\blacksquare
\end{align*}
$$&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;用rejection-sampling算法产生离散随机变量&#34;&gt;用Rejection sampling算法产生离散随机变量&lt;/h3&gt;

&lt;p&gt;产生离散随机变量的方法和产生连续随机变量的方法基本一致，只是这时候目标的概率分布函数&lt;code&gt;$ F $&lt;/code&gt;变成了概率质量函数&lt;code&gt;$ p(k)=P(X=k) $&lt;/code&gt;，辅助的概率分布&lt;code&gt;$ G $&lt;/code&gt;变成了概率质量函数&lt;code&gt;$ q(k)=P(Y=k) $&lt;/code&gt;，并满足条件&lt;code&gt;$ \text{sup}_x\{p(k)/q(k)\}\leqslant c &amp;lt; \infty $&lt;/code&gt;。
&lt;br&gt;
&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;示例-产生服从简单beta分布的随机变量&#34;&gt;示例：产生服从简单Beta分布的随机变量&lt;/h3&gt;

&lt;p&gt;Beta分布的概率密度函数为&lt;code&gt;$ f(x)=bx^n(1-x)^m，x\in (0,1) $&lt;/code&gt;，其中&lt;code&gt;$ b=[\int_0^1x^n(1-x)^m\text{d}x]^{-1} $&lt;/code&gt;为归一化常数。这里我们只研究&lt;code&gt;$ n=m&amp;gt;1 $&lt;/code&gt;的情况，此时Beta分布的概率密度函数关于&lt;code&gt;$ x=\frac{1}{2} $&lt;/code&gt;对称。这里我们选择&lt;code&gt;$ g(y)=1 $&lt;/code&gt;这一均匀分布作为辅助的概率密度函数。因此，&lt;code&gt;$ c=\text{sup}_x\frac{f(x)}{g(x)}=\text{sup}_xf(x) $&lt;/code&gt;当&lt;code&gt;$ x=\frac{1}{2} $&lt;/code&gt;时取到最大，即&lt;code&gt;$ c=b4^{-n} $&lt;/code&gt;。
这样，若要产生服从&lt;code&gt;$ f(x)=b(x(1-x))^n $&lt;/code&gt;这一简单Beta分布的随机变量，只需要：&lt;/p&gt;

&lt;table border=&#39;2&#39; cellpadding=&#39;15px&#39; bordercolor=&#39;#5050&#39;&gt;
&lt;td&gt;
&lt;ol&gt;
&lt;li&gt;产生两个0，1之间的均匀分布随机变量$U_1，U_2$。&lt;/li&gt; &lt;p/&gt;
&lt;li&gt;If $U_2\leqslant 4^n(U_1(1-U_1))^n$，then $X=U_1$; Otherwise goto step 1。&lt;/li&gt; 
&lt;/ol&gt;
&lt;/td&gt;
&lt;/table&gt;</description>
    </item>
    
  </channel>
</rss>